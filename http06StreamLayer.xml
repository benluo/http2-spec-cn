<section anchor="StreamsLayer" title="Streams and Multiplexing">
    <t>
        A "stream" is an independent, bidirectional sequence of frames exchanged between the client
        and server within an HTTP/2 connection. Streams have several important characteristics:
        <list style="symbols">
            <t>
                A single HTTP/2 connection can contain multiple concurrently open streams, with either
                endpoint interleaving frames from multiple streams.
            </t>
            <t>
                Streams can be established and used unilaterally or shared by either the client or
                server.
            </t>
            <t>
                Streams can be closed by either endpoint.
            </t>
            <t>
                The order in which frames are sent on a stream is significant. Recipients process frames
                in the order they are received. In particular, the order of
                <x:ref>HEADERS</x:ref>
                and
                <x:ref>DATA</x:ref>
                frames is semantically significant.
            </t>
            <t>
                Streams are identified by an integer. Stream identifiers are assigned to streams by the
                endpoint initiating the stream.
            </t>
        </list>
    </t>

    <section anchor="StreamStates" title="Stream States">
        <t>
            The lifecycle of a stream is shown in<xref target="StreamStatesFigure"/>.
        </t>

        <figure anchor="StreamStatesFigure" title="Stream States">
            <artwork type="drawing">
                <![CDATA[
                             +--------+
                     send PP |        | recv PP
                    ,--------|  idle  |--------.
                   /         |        |         \
                  v          +--------+          v
           +----------+          |           +----------+
           |          |          | send H /  |          |
    ,------| reserved |          | recv H    | reserved |------.
    |      | (local)  |          |           | (remote) |      |
    |      +----------+          v           +----------+      |
    |          |             +--------+             |          |
    |          |     recv ES |        | send ES     |          |
    |   send H |     ,-------|  open  |-------.     | recv H   |
    |          |    /        |        |        \    |          |
    |          v   v         +--------+         v   v          |
    |      +----------+          |           +----------+      |
    |      |   half   |          |           |   half   |      |
    |      |  closed  |          | send R /  |  closed  |      |
    |      | (remote) |          | recv R    | (local)  |      |
    |      +----------+          |           +----------+      |
    |           |                |                 |           |
    |           | send ES /      |       recv ES / |           |
    |           | send R /       v        send R / |           |
    |           | recv R     +--------+   recv R   |           |
    | send R /  `----------->|        |<-----------'  send R / |
    | recv R                 | closed |               recv R   |
    `----------------------->|        |<----------------------'
                             +--------+

       send:   endpoint sends this frame
       recv:   endpoint receives this frame

       H:  HEADERS frame (with implied CONTINUATIONs)
       PP: PUSH_PROMISE frame (with implied CONTINUATIONs)
       ES: END_STREAM flag
       R:  RST_STREAM frame
]]>
            </artwork>
        </figure>

        <t>
            Note that this diagram shows stream state transitions and the frames and flags that affect
            those transitions only. In this regard,
            <x:ref>CONTINUATION</x:ref>
            frames do not result
            in state transitions; they are effectively part of the
            <x:ref>HEADERS</x:ref>
            or
            <x:ref>PUSH_PROMISE</x:ref>
            that they follow. For the purpose of state transitions, the
            END_STREAM flag is processed as a separate event to the frame that bears it; a
            <x:ref>HEADERS</x:ref>
            frame with the END_STREAM flag set can cause two state transitions.
        </t>
        <t>
            Both endpoints have a subjective view of the state of a stream that could be different
            when frames are in transit. Endpoints do not coordinate the creation of streams; they are
            created unilaterally by either endpoint. The negative consequences of a mismatch in
            states are limited to the "closed" state after sending<x:ref>RST_STREAM</x:ref>, where
            frames might be received for some time after closing.
        </t>
        <t>
            Streams have the following states:
            <list style="hanging">

                <x:lt hangText="idle:">
                    <t>
                        <vspace blankLines="0"/>
                        All streams start in the "idle" state.
                    </t>
                    <t>
                        The following transitions are valid from this state:
                        <list style="symbols">
                            <t>
                                Sending or receiving a
                                <x:ref>HEADERS</x:ref>
                                frame causes the stream to become
                                "open". The stream identifier is selected as described in<xref
                                    target="StreamIdentifiers"/>. The same
                                <x:ref>HEADERS</x:ref>
                                frame can also
                                cause a stream to immediately become "half-closed".
                            </t>
                            <t>
                                Sending a
                                <x:ref>PUSH_PROMISE</x:ref>
                                frame on another stream reserves the idle
                                stream that is identified for later use. The stream state for the reserved
                                stream transitions to "reserved (local)".
                            </t>
                            <t>
                                Receiving a
                                <x:ref>PUSH_PROMISE</x:ref>
                                frame on another stream reserves an idle
                                stream that is identified for later use. The stream state for the reserved
                                stream transitions to "reserved (remote)".
                            </t>
                            <t>
                                Note that the
                                <x:ref>PUSH_PROMISE</x:ref>
                                frame is not sent on the idle
                                stream but references the newly reserved stream in the Promised Stream ID
                                field.
                            </t>
                        </list>
                    </t>
                    <t>
                        Receiving any frame other than
                        <x:ref>HEADERS</x:ref>
                        or
                        <x:ref>PRIORITY</x:ref>
                        on
                        a stream in this state MUST be treated as a
                        <xref
                                target="ConnectionErrorHandler">connection error
                        </xref>
                        of type
                        <x:ref>PROTOCOL_ERROR</x:ref>.
                    </t>
                </x:lt>

                <x:lt hangText="reserved (local):">
                    <t>
                        <vspace blankLines="0"/>
                        A stream in the "reserved (local)" state is one that has been promised by sending a
                        <x:ref>PUSH_PROMISE</x:ref>
                        frame. A
                        <x:ref>PUSH_PROMISE</x:ref>
                        frame reserves an
                        idle stream by associating the stream with an open stream that was initiated by the
                        remote peer (see<xref target="PushResources"/>).
                    </t>
                    <t>
                        In this state, only the following transitions are possible:
                        <list style="symbols">
                            <t>
                                The endpoint can send a
                                <x:ref>HEADERS</x:ref>
                                frame. This causes the stream to
                                open in a "half-closed (remote)" state.
                            </t>
                            <t>
                                Either endpoint can send a
                                <x:ref>RST_STREAM</x:ref>
                                frame to cause the stream
                                to become "closed". This releases the stream reservation.
                            </t>
                        </list>
                    </t>
                    <t>
                        An endpoint MUST NOT send any type of frame other than<x:ref>HEADERS</x:ref>,
                        <x:ref>RST_STREAM</x:ref>, or
                        <x:ref>PRIORITY</x:ref>
                        in this state.
                    </t>
                    <t>
                        A
                        <x:ref>PRIORITY</x:ref>
                        or
                        <x:ref>WINDOW_UPDATE</x:ref>
                        frame MAY be received in
                        this state. Receiving any type of frame other than<x:ref>RST_STREAM</x:ref>,
                        <x:ref>PRIORITY</x:ref>, or
                        <x:ref>WINDOW_UPDATE</x:ref>
                        on a stream in this state
                        MUST be treated as a
                        <xref target="ConnectionErrorHandler">connection error</xref>
                        of type<x:ref>PROTOCOL_ERROR</x:ref>.
                    </t>
                </x:lt>

                <x:lt hangText="reserved (remote):">
                    <t>
                        <vspace blankLines="0"/>
                        A stream in the "reserved (remote)" state has been reserved by a remote peer.
                    </t>
                    <t>
                        In this state, only the following transitions are possible:
                        <list style="symbols">
                            <t>
                                Receiving a
                                <x:ref>HEADERS</x:ref>
                                frame causes the stream to transition to
                                "half-closed (local)".
                            </t>
                            <t>
                                Either endpoint can send a
                                <x:ref>RST_STREAM</x:ref>
                                frame to cause the stream
                                to become "closed". This releases the stream reservation.
                            </t>
                        </list>
                    </t>
                    <t>
                        An endpoint MAY send a
                        <x:ref>PRIORITY</x:ref>
                        frame in this state to reprioritize
                        the reserved stream. An endpoint MUST NOT send any type of frame other than
                        <x:ref>RST_STREAM</x:ref>,<x:ref>WINDOW_UPDATE</x:ref>, or
                        <x:ref>PRIORITY</x:ref>
                        in this state.
                    </t>
                    <t>
                        Receiving any type of frame other than<x:ref>HEADERS</x:ref>,
                        <x:ref>RST_STREAM</x:ref>, or
                        <x:ref>PRIORITY</x:ref>
                        on a stream in this state MUST
                        be treated as a
                        <xref target="ConnectionErrorHandler">connection error</xref>
                        of
                        type<x:ref>PROTOCOL_ERROR</x:ref>.
                    </t>
                </x:lt>

                <x:lt hangText="open:">
                    <t>
                        <vspace blankLines="0"/>
                        A stream in the "open" state may be used by both peers to send frames of any type.
                        In this state, sending peers observe advertised<xref target="FlowControl">stream-level
                        flow-control limits</xref>.
                    </t>
                    <t>
                        From this state, either endpoint can send a frame with an END_STREAM flag set, which
                        causes the stream to transition into one of the "half-closed" states. An endpoint
                        sending an END_STREAM flag causes the stream state to become "half-closed (local)";
                        an endpoint receiving an END_STREAM flag causes the stream state to become "half-closed
                        (remote)".
                    </t>
                    <t>
                        Either endpoint can send a
                        <x:ref>RST_STREAM</x:ref>
                        frame from this state, causing
                        it to transition immediately to "closed".
                    </t>
                </x:lt>

                <x:lt hangText="half-closed (local):">
                    <t>
                        <vspace blankLines="0"/>
                        A stream that is in the "half-closed (local)" state cannot be used for sending
                        frames other than<x:ref>WINDOW_UPDATE</x:ref>,<x:ref>PRIORITY</x:ref>, and
                        <x:ref>RST_STREAM</x:ref>.
                    </t>
                    <t>
                        A stream transitions from this state to "closed" when a frame that contains an
                        END_STREAM flag is received or when either peer sends a
                        <x:ref>RST_STREAM</x:ref>
                        frame.
                    </t>
                    <t>
                        An endpoint can receive any type of frame in this state. Providing flow-control
                        credit using
                        <x:ref>WINDOW_UPDATE</x:ref>
                        frames is necessary to continue receiving
                        flow-controlled frames. In this state, a receiver can ignore
                        <x:ref>WINDOW_UPDATE</x:ref>
                        frames,
                        which might arrive for a short period after a frame bearing the
                        END_STREAM flag is sent.
                    </t>
                    <t>
                        <x:ref>PRIORITY</x:ref>
                        frames received in this state are used to reprioritize
                        streams that depend on the identified stream.
                    </t>
                </x:lt>

                <x:lt hangText="half-closed (remote):">
                    <t>
                        <vspace blankLines="0"/>
                        A stream that is "half-closed (remote)" is no longer being used by the peer to send
                        frames. In this state, an endpoint is no longer obligated to maintain a receiver
                        flow-control window.
                    </t>
                    <t>
                        If an endpoint receives additional frames, other
                        than<x:ref>WINDOW_UPDATE</x:ref>,<x:ref>PRIORITY</x:ref>, or
                        <x:ref>RST_STREAM</x:ref>, for a stream that is in this state, it MUST respond with a
                        <xref
                                target="StreamErrorHandler">stream error
                        </xref>
                        of type
                        <x:ref>STREAM_CLOSED</x:ref>.
                    </t>
                    <t>
                        A stream that is "half-closed (remote)" can be used by the endpoint to send frames
                        of any type. In this state, the endpoint continues to observe advertised<xref
                            target="FlowControl">stream-level flow-control limits</xref>.
                    </t>
                    <t>
                        A stream can transition from this state to "closed" by sending a frame that contains
                        an END_STREAM flag or when either peer sends a
                        <x:ref>RST_STREAM</x:ref>
                        frame.
                    </t>
                </x:lt>

                <x:lt hangText="closed:">
                    <t>
                        <vspace blankLines="0"/>
                        The "closed" state is the terminal state.
                    </t>
                    <t>
                        An endpoint MUST NOT send frames other than
                        <x:ref>PRIORITY</x:ref>
                        on a closed
                        stream. An endpoint that receives any frame other than
                        <x:ref>PRIORITY</x:ref>
                        after receiving a
                        <x:ref>RST_STREAM</x:ref>
                        MUST treat that as a
                        <xref
                                target="StreamErrorHandler">stream error
                        </xref>
                        of type
                        <x:ref>STREAM_CLOSED</x:ref>. Similarly, an endpoint that receives any frames after
                        receiving a frame with the END_STREAM flag set MUST treat that as a
                        <xref
                                target="ConnectionErrorHandler">connection error
                        </xref>
                        of type
                        <x:ref>STREAM_CLOSED</x:ref>, unless the frame is permitted as described below.
                    </t>
                    <t>
                        <x:ref>WINDOW_UPDATE</x:ref>
                        or
                        <x:ref>RST_STREAM</x:ref>
                        frames can be received in
                        this state for a short period after a
                        <x:ref>DATA</x:ref>
                        or
                        <x:ref>HEADERS</x:ref>
                        frame containing an END_STREAM flag is sent. Until the remote peer receives and
                        processes
                        <x:ref>RST_STREAM</x:ref>
                        or the frame bearing the END_STREAM flag, it
                        might send frames of these types. Endpoints MUST ignore
                        <x:ref>WINDOW_UPDATE</x:ref>
                        or
                        <x:ref>RST_STREAM</x:ref>
                        frames received in this
                        state, though endpoints MAY choose to treat frames that arrive a significant time
                        after sending END_STREAM as a
                        <xref target="ConnectionErrorHandler">connection
                            error
                        </xref>
                        of type<x:ref>PROTOCOL_ERROR</x:ref>.
                    </t>
                    <t>
                        <x:ref>PRIORITY</x:ref>
                        frames can be sent on closed streams to prioritize streams
                        that are dependent on the closed stream. Endpoints SHOULD process
                        <x:ref>PRIORITY</x:ref>
                        frames, though they can be ignored if the stream has been
                        removed from the dependency tree (see<xref target="priority-gc"/>).
                    </t>
                    <t>
                        If this state is reached as a result of sending a
                        <x:ref>RST_STREAM</x:ref>
                        frame,
                        the peer that receives the
                        <x:ref>RST_STREAM</x:ref>
                        might have already sent &mdash; or
                        enqueued for sending &mdash; frames on the stream that cannot be withdrawn. An endpoint
                        MUST ignore frames that it receives on closed streams after it has sent a
                        <x:ref>RST_STREAM</x:ref>
                        frame. An endpoint MAY choose to limit the period over
                        which it ignores frames and treat frames that arrive after this time as being in
                        error.
                    </t>
                    <t>
                        Flow-controlled frames (i.e.,<x:ref>DATA</x:ref>) received after sending
                        <x:ref>RST_STREAM</x:ref>
                        are counted toward the connection flow-control window.
                        Even though these frames might be ignored, because they are sent before the sender
                        receives the<x:ref>RST_STREAM</x:ref>, the sender will consider the frames to count
                        against the flow-control window.
                    </t>
                    <t>
                        An endpoint might receive a
                        <x:ref>PUSH_PROMISE</x:ref>
                        frame after it sends
                        <x:ref>RST_STREAM</x:ref>.
                        <x:ref>PUSH_PROMISE</x:ref>
                        causes a stream to become
                        "reserved" even if the associated stream has been reset. Therefore, a
                        <x:ref>RST_STREAM</x:ref>
                        is needed to close an unwanted promised stream.
                    </t>
                </x:lt>
            </list>
        </t>
        <t>
            In the absence of more specific guidance elsewhere in this document, implementations
            SHOULD treat the receipt of a frame that is not expressly permitted in the description of
            a state as a
            <xref target="ConnectionErrorHandler">connection error</xref>
            of type
            <x:ref>PROTOCOL_ERROR</x:ref>. Note that
            <x:ref>PRIORITY</x:ref>
            can be sent and received
            in any stream state. Frames of unknown types are ignored.
        </t>
        <t>
            An example of the state transitions for an HTTP request/response exchange can be found in
            <xref target="HttpSequence"/>. An example of the state transitions for server push can be
            found in Sections
            <xref target="PushRequests" format="counter"/>
            and<xref target="PushResponses" format="counter"/>.
        </t>

        <section anchor="StreamIdentifiers" title="Stream Identifiers">
            <t>
                Streams are identified with an unsigned 31-bit integer. Streams initiated by a client
                MUST use odd-numbered stream identifiers; those initiated by the server MUST use
                even-numbered stream identifiers. A stream identifier of zero (0x0) is used for
                connection control messages; the stream identifier of zero cannot be used to establish a
                new stream.
            </t>
            <t>
                HTTP/1.1 requests that are upgraded to HTTP/2 (see<xref target="discover-http"/>) are
                responded to with a stream identifier of one (0x1). After the upgrade
                completes, stream 0x1 is "half-closed (local)" to the client. Therefore, stream 0x1
                cannot be selected as a new stream identifier by a client that upgrades from HTTP/1.1.
            </t>
            <t>
                The identifier of a newly established stream MUST be numerically greater than all
                streams that the initiating endpoint has opened or reserved. This governs streams that
                are opened using a
                <x:ref>HEADERS</x:ref>
                frame and streams that are reserved using
                <x:ref>PUSH_PROMISE</x:ref>. An endpoint that receives an unexpected stream identifier
                MUST respond with a
                <xref target="ConnectionErrorHandler">connection error</xref>
                of
                type<x:ref>PROTOCOL_ERROR</x:ref>.
            </t>
            <t>
                The first use of a new stream identifier implicitly closes all streams in the "idle"
                state that might have been initiated by that peer with a lower-valued stream identifier.
                For example, if a client sends a
                <x:ref>HEADERS</x:ref>
                frame on stream 7 without ever
                sending a frame on stream 5, then stream 5 transitions to the "closed" state when the
                first frame for stream 7 is sent or received.
            </t>
            <t>
                Stream identifiers cannot be reused. Long-lived connections can result in an endpoint
                exhausting the available range of stream identifiers. A client that is unable to
                establish a new stream identifier can establish a new connection for new streams. A
                server that is unable to establish a new stream identifier can send a
                <x:ref>GOAWAY</x:ref>
                frame so that the client is forced to open a new connection for
                new streams.
            </t>
        </section>

        <section title="Stream Concurrency">
            <t>
                A peer can limit the number of concurrently active streams using the
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>
                parameter (see<xref
                    target="SettingValues"/>) within a
                <x:ref>SETTINGS</x:ref>
                frame. The maximum concurrent
                streams setting is specific to each endpoint and applies only to the peer that receives
                the setting. That is, clients specify the maximum number of concurrent streams the
                server can initiate, and servers specify the maximum number of concurrent streams the
                client can initiate.
            </t>
            <t>
                Streams that are in the "open" state or in either of the "half-closed" states count toward
                the maximum number of streams that an endpoint is permitted to open. Streams in any of
                these three states count toward the limit advertised in the
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>
                setting. Streams in either of the
                "reserved" states do not count toward the stream limit.
            </t>
            <t>
                Endpoints MUST NOT exceed the limit set by their peer. An endpoint that receives a
                <x:ref>HEADERS</x:ref>
                frame that causes its advertised concurrent stream limit to be
                exceeded MUST treat this as a
                <xref target="StreamErrorHandler">stream error</xref>
                of
                type
                <x:ref>PROTOCOL_ERROR</x:ref>
                or<x:ref>REFUSED_STREAM</x:ref>. The choice of
                error code determines whether the endpoint wishes to enable automatic retry (see<xref
                    target="Reliability"/>) for details).
            </t>
            <t>
                An endpoint that wishes to reduce the value of
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>
                to a value that is below the current
                number of open streams can either close streams that exceed the new value or allow
                streams to complete.
            </t>
        </section>
    </section>

    <section anchor="FlowControl" title="Flow Control">
        <t>
            Using streams for multiplexing introduces contention over use of the TCP connection,
            resulting in blocked streams. A flow-control scheme ensures that streams on the same
            connection do not destructively interfere with each other. Flow control is used for both
            individual streams and for the connection as a whole.
        </t>
        <t>
            HTTP/2 provides for flow control through use of the<xref
                target="WINDOW_UPDATE">WINDOW_UPDATE frame</xref>.
        </t>

        <section anchor="fc-principles" title="Flow-Control Principles">
            <t>
                HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be
                used without requiring protocol changes. Flow control in HTTP/2 has the following
                characteristics:
                <list style="numbers">
                    <t>
                        Flow control is specific to a connection. Both types of flow control are between
                        the endpoints of a single hop and not over the entire end-to-end path.
                    </t>
                    <t>
                        Flow control is based on
                        <x:ref>WINDOW_UPDATE</x:ref>
                        frames. Receivers advertise how many octets
                        they are prepared to receive on a stream and for the entire connection. This is a
                        credit-based scheme.
                    </t>
                    <t>
                        Flow control is directional with overall control provided by the receiver. A
                        receiver MAY choose to set any window size that it desires for each stream and for
                        the entire connection. A sender MUST respect flow-control limits imposed by a
                        receiver. Clients, servers, and intermediaries all independently advertise their
                        flow-control window as a receiver and abide by the flow-control limits set by
                        their peer when sending.
                    </t>
                    <t>
                        The initial value for the flow-control window is 65,535 octets for both new streams
                        and the overall connection.
                    </t>
                    <t>
                        The frame type determines whether flow control applies to a frame. Of the frames
                        specified in this document, only
                        <x:ref>DATA</x:ref>
                        frames are subject to flow
                        control; all other frame types do not consume space in the advertised flow-control
                        window. This ensures that important control frames are not blocked by flow control.
                    </t>
                    <t>
                        Flow control cannot be disabled.
                    </t>
                    <t>
                        HTTP/2 defines only the format and semantics of the
                        <x:ref>WINDOW_UPDATE</x:ref>
                        frame (<xref target="WINDOW_UPDATE"/>). This document does not stipulate how a
                        receiver decides when to send this frame or the value that it sends, nor does it
                        specify how a sender chooses to send packets. Implementations are able to select
                        any algorithm that suits their needs.
                    </t>
                </list>
            </t>
            <t>
                Implementations are also responsible for managing how requests and responses are sent
                based on priority, choosing how to avoid head-of-line blocking for requests, and
                managing the creation of new streams. Algorithm choices for these could interact with
                any flow-control algorithm.
            </t>
        </section>

        <section anchor="DisableFlowControl" title="Appropriate Use of Flow Control">
            <t>
                Flow control is defined to protect endpoints that are operating under resource
                constraints. For example, a proxy needs to share memory between many connections and
                also might have a slow upstream connection and a fast downstream one. Flow-control
                addresses cases where the receiver is unable to process data on one stream yet wants to
                continue to process other streams in the same connection.
            </t>
            <t>
                Deployments that do not require this capability can advertise a flow-control window of
                the maximum size (2<x:sup>31</x:sup>-1) and can maintain this window by sending a
                <x:ref>WINDOW_UPDATE</x:ref>
                frame when any data is received. This effectively disables
                flow control for that receiver. Conversely, a sender is always subject to the
                flow-control window advertised by the receiver.
            </t>
            <t>
                Deployments with constrained resources (for example, memory) can employ flow control to
                limit the amount of memory a peer can consume. Note, however, that this can lead to
                suboptimal use of available network resources if flow control is enabled without
                knowledge of the bandwidth-delay product (see<xref target="RFC7323"/>).
            </t>
            <t>
                Even with full awareness of the current bandwidth-delay product, implementation of flow
                control can be difficult. When using flow control, the receiver MUST read from the TCP
                receive buffer in a timely fashion. Failure to do so could lead to a deadlock when
                critical frames, such as<x:ref>WINDOW_UPDATE</x:ref>, are not read and acted upon.
            </t>
        </section>
    </section>

    <section anchor="StreamPriority" title="Stream Priority">
        <t>
            A client can assign a priority for a new stream by including prioritization information in
            the
            <xref target="HEADERS">HEADERS frame</xref>
            that opens the stream. At any other time,
            the
            <xref target="PRIORITY">PRIORITY frame</xref>
            can be used to change the priority of a
            stream.
        </t>
        <t>
            The purpose of prioritization is to allow an endpoint to express how it would prefer its
            peer to allocate resources when managing concurrent streams. Most importantly, priority can
            be used to select streams for transmitting frames when there is limited capacity for
            sending.
        </t>
        <t>
            Streams can be prioritized by marking them as dependent on the completion of other streams
            (<xref target="pri-depend"/>). Each dependency is assigned a relative weight, a number
            that is used to determine the relative proportion of available resources that are assigned
            to streams dependent on the same stream.
        </t>
        <!--
  Note that stream dependencies have not yet been validated in practice.  The theory
  might be fairly sound, but there are no implementations currently sending these.  If it
  turns out that they are not useful, or actively harmful, implementations will be requested
  to avoid creating stream dependencies.
-->
        <t>
            Explicitly setting the priority for a stream is input to a prioritization process. It
            does not guarantee any particular processing or transmission order for the stream relative
            to any other stream. An endpoint cannot force a peer to process concurrent streams in a
            particular order using priority. Expressing priority is therefore only a suggestion.
        </t>
        <t>
            Prioritization information can be omitted from messages. Defaults are used prior to any
            explicit values being provided (<xref target="pri-default"/>).
        </t>

        <section title="Stream Dependencies" anchor="pri-depend">
            <t>
                Each stream can be given an explicit dependency on another stream. Including a
                dependency expresses a preference to allocate resources to the identified stream rather
                than to the dependent stream.
            </t>
            <t>
                A stream that is not dependent on any other stream is given a stream dependency of 0x0.
                In other words, the non-existent stream 0 forms the root of the tree.
            </t>
            <t>
                A stream that depends on another stream is a dependent stream. The stream upon which a
                stream is dependent is a parent stream. A dependency on a stream that is not currently
                in the tree &mdash; such as a stream in the "idle" state &mdash; results in that stream being
                given
                a<xref target="pri-default">default priority</xref>.
            </t>
            <t>
                When assigning a dependency on another stream, the stream is added as a new dependency
                of the parent stream. Dependent streams that share the same parent are not ordered with
                respect to each other. For example, if streams B and C are dependent on stream A, and
                if stream D is created with a dependency on stream A, this results in a dependency order
                of A followed by B, C, and D in any order.
            </t>
            <figure anchor="ExampleofDefaultDependencyCreation"
                    title="Example of Default Dependency Creation">
                <artwork type="inline"><![CDATA[
    A                 A
   / \      ==>      /|\
  B   C             B D C
]]></artwork>
            </figure>
            <t>
                An exclusive flag allows for the insertion of a new level of dependencies. The
                exclusive flag causes the stream to become the sole dependency of its parent stream,
                causing other dependencies to become dependent on the exclusive stream. In the
                previous example, if stream D is created with an exclusive dependency on stream A, this
                results in D becoming the dependency parent of B and C.
            </t>
            <figure anchor="ExampleofExclusiveDependencyCreation"
                    title="Example of Exclusive Dependency Creation">
                <artwork type="inline"><![CDATA[
                      A
    A                 |
   / \      ==>       D
  B   C              / \
                    B   C
]]></artwork>
            </figure>
            <t>
                Inside the dependency tree, a dependent stream SHOULD only be allocated resources if
                either all of the streams that it depends on (the chain of parent streams up to 0x0)
                are closed or it is not possible to make progress on them.
            </t>
            <t>
                A stream cannot depend on itself. An endpoint MUST treat this as a
                <xref
                        target="StreamErrorHandler">stream error
                </xref>
                of type<x:ref>PROTOCOL_ERROR</x:ref>.
            </t>
        </section>

        <section title="Dependency Weighting">
            <t>
                All dependent streams are allocated an integer weight between 1 and 256 (inclusive).
            </t>
            <t>
                Streams with the same parent SHOULD be allocated resources proportionally based on their
                weight. Thus, if stream B depends on stream A with weight 4, stream C depends on stream A
                with weight 12, and no progress can be made on stream A, stream B ideally receives one-third
                of the resources allocated to stream C.
            </t>
        </section>

        <section anchor="reprioritize" title="Reprioritization">
            <t>
                Stream priorities are changed using the
                <x:ref>PRIORITY</x:ref>
                frame. Setting a
                dependency causes a stream to become dependent on the identified parent stream.
            </t>
            <t>
                Dependent streams move with their parent stream if the parent is reprioritized. Setting
                a dependency with the exclusive flag for a reprioritized stream causes all the
                dependencies of the new parent stream to become dependent on the reprioritized stream.
            </t>
            <t>
                If a stream is made dependent on one of its own dependencies, the formerly dependent
                stream is first moved to be dependent on the reprioritized stream's previous parent.
                The moved dependency retains its weight.
            </t>
            <figure anchor="ExampleofDependencyReordering"
                    title="Example of Dependency Reordering">
                <preamble>
                    For example, consider an original dependency tree where B and C depend on A, D and E
                    depend on C, and F depends on D. If A is made dependent on D, then D takes the place
                    of A. All other dependency relationships stay the same, except for F, which becomes
                    dependent on A if the reprioritization is exclusive.
                </preamble>
                <artwork type="inline"><![CDATA[
    x                x                x                 x
    |               / \               |                 |
    A              D   A              D                 D
   / \            /   / \            / \                |
  B   C     ==>  F   B   C   ==>    F   A       OR      A
     / \                 |             / \             /|\
    D   E                E            B   C           B C F
    |                                     |             |
    F                                     E             E
               (intermediate)   (non-exclusive)    (exclusive)
]]></artwork>
            </figure>
        </section>

        <section anchor="priority-gc" title="Prioritization State Management">
            <t>
                When a stream is removed from the dependency tree, its dependencies can be moved to
                become dependent on the parent of the closed stream. The weights of new dependencies
                are recalculated by distributing the weight of the dependency of the closed stream
                proportionally based on the weights of its dependencies.
            </t>
            <t>
                Streams that are removed from the dependency tree cause some prioritization information
                to be lost. Resources are shared between streams with the same parent stream, which
                means that if a stream in that set closes or becomes blocked, any spare capacity
                allocated to a stream is distributed to the immediate neighbors of the stream. However,
                if the common dependency is removed from the tree, those streams share resources with
                streams at the next highest level.
            </t>
            <t>
                For example, assume streams A and B share a parent, and streams C and D both depend on
                stream A. Prior to the removal of stream A, if streams A and D are unable to proceed,
                then stream C receives all the resources dedicated to stream A. If stream A is removed
                from the tree, the weight of stream A is divided between streams C and D. If stream D
                is still unable to proceed, this results in stream C receiving a reduced proportion of
                resources. For equal starting weights, C receives one third, rather than one half, of
                available resources.
            </t>
            <t>
                It is possible for a stream to become closed while prioritization information that
                creates a dependency on that stream is in transit. If a stream identified in a
                dependency has no associated priority information, then the dependent stream is instead
                assigned a<xref target="pri-default">default priority</xref>. This potentially creates
                suboptimal prioritization, since the stream could be given a priority that is different
                from what is intended.
            </t>
            <t>
                To avoid these problems, an endpoint SHOULD retain stream prioritization state for a
                period after streams become closed. The longer state is retained, the lower the chance
                that streams are assigned incorrect or default priority values.
            </t>
            <t>
                Similarly, streams that are in the "idle" state can be assigned priority or become a
                parent of other streams. This allows for the creation of a grouping node in the
                dependency tree, which enables more flexible expressions of priority. Idle streams
                begin with a<xref target="pri-default">default priority</xref>.
            </t>
            <t>
                The retention of priority information for streams that are not counted toward the limit
                set by
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>
                could create a large state burden
                for an endpoint. Therefore, the amount of prioritization state that is retained MAY be
                limited.
            </t>
            <t>
                The amount of additional state an endpoint maintains for prioritization could be
                dependent on load; under high load, prioritization state can be discarded to limit
                resource commitments. In extreme cases, an endpoint could even discard prioritization
                state for active or reserved streams. If a limit is applied, endpoints SHOULD maintain
                state for at least as many streams as allowed by their setting for
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>. Implementations SHOULD also attempt to
                retain state for streams that are in active use in the priority tree.
            </t>
            <t>
                If it has retained enough state to do so, an endpoint receiving a
                <x:ref>PRIORITY</x:ref>
                frame that changes the priority of a
                closed stream SHOULD alter the dependencies of the streams that depend on it.
            </t>
        </section>

        <section title="Default Priorities" anchor="pri-default">
            <t>
                All streams are initially assigned a non-exclusive dependency on stream 0x0.
                <xref
                        target="PushResources">Pushed streams
                </xref>
                initially depend on their associated
                stream. In both cases, streams are assigned a default weight of 16.
            </t>
        </section>
    </section>

    <section anchor="ErrorHandler" title="Error Handling">
        <t>
            HTTP/2 framing permits two classes of error:
            <list style="symbols">
                <t>
                    An error condition that renders the entire connection unusable is a connection error.
                </t>
                <t>
                    An error in an individual stream is a stream error.
                </t>
            </list>
        </t>
        <t>
            A list of error codes is included in<xref target="ErrorCodes"/>.
        </t>

        <section anchor="ConnectionErrorHandler" title="Connection Error Handling">
            <t>
                A connection error is any error that prevents further processing of the frame
                layer or corrupts any connection state.
            </t>
            <t>
                An endpoint that encounters a connection error SHOULD first send a
                <x:ref>GOAWAY</x:ref>
                frame (<xref target="GOAWAY"/>) with the stream identifier of the last stream that it
                successfully received from its peer. The
                <x:ref>GOAWAY</x:ref>
                frame includes an error
                code that indicates why the connection is terminating. After sending the
                <x:ref>GOAWAY</x:ref>
                frame for an error condition, the endpoint MUST close the TCP
                connection.
            </t>
            <t>
                It is possible that the
                <x:ref>GOAWAY</x:ref>
                will not be reliably received by the
                receiving endpoint (
                <xref target="RFC7230" x:fmt=","
                      x:rel="#persistent.tear-down"/>
                describes how an immediate connection close
                can result in data loss). In the event of a connection error,
                <x:ref>GOAWAY</x:ref>
                only provides a best-effort attempt to communicate with the peer
                about why the connection is being terminated.
            </t>
            <t>
                An endpoint can end a connection at any time. In particular, an endpoint MAY choose to
                treat a stream error as a connection error. Endpoints SHOULD send a
                <x:ref>GOAWAY</x:ref>
                frame when ending a connection, providing that circumstances
                permit it.
            </t>
        </section>

        <section anchor="StreamErrorHandler" title="Stream Error Handling">
            <t>
                A stream error is an error related to a specific stream that does not affect processing
                of other streams.
            </t>
            <t>
                An endpoint that detects a stream error sends a
                <x:ref>RST_STREAM</x:ref>
                frame (<xref
                    target="RST_STREAM"/>) that contains the stream identifier of the stream where the error
                occurred. The
                <x:ref>RST_STREAM</x:ref>
                frame includes an error code that indicates the
                type of error.
            </t>
            <t>
                A
                <x:ref>RST_STREAM</x:ref>
                is the last frame that an endpoint can send on a stream.
                The peer that sends the
                <x:ref>RST_STREAM</x:ref>
                frame MUST be prepared to receive any
                frames that were sent or enqueued for sending by the remote peer. These frames can be
                ignored, except where they modify connection state (such as the state maintained for
                <xref target="HeaderBlock">header compression</xref>
                or flow control).
            </t>
            <t>
                Normally, an endpoint SHOULD NOT send more than one
                <x:ref>RST_STREAM</x:ref>
                frame for
                any stream. However, an endpoint MAY send additional
                <x:ref>RST_STREAM</x:ref>
                frames if
                it receives frames on a closed stream after more than a round-trip time. This behavior
                is permitted to deal with misbehaving implementations.
            </t>
            <t>
                To avoid looping, an endpoint MUST NOT send a
                <x:ref>RST_STREAM</x:ref>
                in response to a
                <x:ref>RST_STREAM</x:ref>
                frame.
            </t>
        </section>

        <section title="Connection Termination">
            <t>
                If the TCP connection is closed or reset while streams remain in "open" or "half-closed"
                state, then the affected streams cannot be automatically retried (see
                <xref
                        target="Reliability"/>
                for details).
            </t>
        </section>
    </section>

    <section anchor="extensibility" title="Extending HTTP/2">
        <t>
            HTTP/2 permits extension of the protocol. Within the limitations described in this
            section, protocol extensions can be used to provide additional services or alter
            any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2
            connection.
        </t>
        <t>
            This applies to the protocol elements defined in this document. This does not affect the
            existing options for extending HTTP, such as defining new methods, status codes, or header
            fields.
        </t>
        <t>
            Extensions are permitted to use new<xref target="FrameHeader">frame types</xref>, new
            <xref target="SettingValues">settings</xref>, or new<xref target="ErrorCodes">error
            codes</xref>. Registries are established for managing these extension points:<xref
                target="iana-frames">frame types</xref>,<xref target="iana-settings">settings</xref>, and
            <xref target="iana-errors">error codes</xref>.
        </t>
        <t>
            Implementations MUST ignore unknown or unsupported values in all extensible protocol
            elements. Implementations MUST discard frames that have unknown or unsupported types.
            This means that any of these extension points can be safely used by extensions without
            prior arrangement or negotiation. However, extension frames that appear in the middle of
            a
            <xref target="HeaderBlock">header block</xref>
            are not permitted; these MUST be treated
            as a
            <xref target="ConnectionErrorHandler">connection error</xref>
            of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
        </t>
        <t>
            Extensions that could change the semantics of existing protocol components MUST be
            negotiated before being used. For example, an extension that changes the layout of the
            <x:ref>HEADERS</x:ref>
            frame cannot be used until the peer has given a positive signal
            that this is acceptable. In this case, it could also be necessary to coordinate when the
            revised layout comes into effect. Note that treating any frames other than
            <x:ref>DATA</x:ref>
            frames as flow controlled is such a change in semantics and can only
            be done through negotiation.
        </t>
        <t>
            This document doesn't mandate a specific method for negotiating the use of an extension
            but notes that a
            <xref target="SettingValues">setting</xref>
            could be used for that
            purpose. If both peers set a value that indicates willingness to use the extension, then
            the extension can be used. If a setting is used for extension negotiation, the initial
            value MUST be defined in such a fashion that the extension is initially disabled.
        </t>
    </section>
</section>