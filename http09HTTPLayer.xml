<section anchor="HTTPLayer" title="HTTP Message Exchanges">
    <t>
        HTTP/2 is intended to be as compatible as possible with current uses of HTTP. This means
        that, from the application perspective, the features of the protocol are largely
        unchanged. To achieve this, all request and response semantics are preserved, although the
        syntax of conveying those semantics has changed.
    </t>
    <t>
        Thus, the specification and requirements of HTTP/1.1 Semantics and Content<xref
            target="RFC7231"/>, Conditional Requests<xref target="RFC7232"/>, Range Requests<xref
            target="RFC7233"/>, Caching<xref target="RFC7234"/>, and Authentication
        <xref
                target="RFC7235"/>
        are applicable to HTTP/2. Selected portions of HTTP/1.1 Message Syntax
        and Routing<xref target="RFC7230"/>, such as the HTTP and HTTPS URI schemes, are also
        applicable in HTTP/2, but the expression of those semantics for this protocol are defined
        in the sections below.
    </t>

    <section anchor="HttpSequence" title="HTTP Request/Response Exchange">
        <t>
            A client sends an HTTP request on a new stream, using a previously unused<xref
                target="StreamIdentifiers">stream identifier</xref>. A server sends an HTTP response on
            the same stream as the request.
        </t>
        <t>
            An HTTP message (request or response) consists of:
            <list style="numbers">
                <t>
                    for a response only, zero or more
                    <x:ref>HEADERS</x:ref>
                    frames (each followed by zero
                    or more
                    <x:ref>CONTINUATION</x:ref>
                    frames) containing the message headers of
                    informational (1xx) HTTP responses (see
                    <xref target="RFC7230" x:fmt=","
                          x:rel="#header.fields"/>
                    and<xref target="RFC7231" x:fmt="," x:rel="#status.1xx"/>),
                </t>
                <t>
                    one
                    <x:ref>HEADERS</x:ref>
                    frame (followed by zero or more
                    <x:ref>CONTINUATION</x:ref>
                    frames) containing the message headers (see<xref target="RFC7230" x:fmt=","
                                                                     x:rel="#header.fields"/>),
                </t>
                <t>
                    zero or more
                    <x:ref>DATA</x:ref>
                    frames containing the payload body (see<xref
                        target="RFC7230" x:fmt="," x:rel="#message.body"/>), and
                </t>
                <t>
                    optionally, one
                    <x:ref>HEADERS</x:ref>
                    frame, followed by zero or more
                    <x:ref>CONTINUATION</x:ref>
                    frames containing the trailer-part, if present (see<xref
                        target="RFC7230" x:fmt="," x:rel="#chunked.trailer.part"/>).
                </t>
            </list>
            The last frame in the sequence bears an END_STREAM flag, noting that a
            <x:ref>HEADERS</x:ref>
            frame bearing the END_STREAM flag can be followed by
            <x:ref>CONTINUATION</x:ref>
            frames that carry any remaining portions of the header block.
        </t>
        <t>
            Other frames (from any stream) MUST NOT occur between the
            <x:ref>HEADERS</x:ref>
            frame
            and any
            <x:ref>CONTINUATION</x:ref>
            frames that might follow.
        </t>

        <t>
            HTTP/2 uses DATA frames to carry message payloads. The
            <spanx
                    style="verb">chunked
            </spanx>
            transfer encoding defined in
            <xref target="RFC7230"
                  x:fmt="of" x:rel="#chunked.encoding"/>
            MUST NOT be used in HTTP/2.
        </t>

        <t>
            Trailing header fields are carried in a header block that also terminates the stream.
            Such a header block is a sequence starting with a
            <x:ref>HEADERS</x:ref>
            frame, followed
            by zero or more
            <x:ref>CONTINUATION</x:ref>
            frames, where the
            <x:ref>HEADERS</x:ref>
            frame
            bears an END_STREAM flag. Header blocks after the first that do not terminate the stream
            are not part of an HTTP request or response.
        </t>
        <t>
            A
            <x:ref>HEADERS</x:ref>
            frame (and associated
            <x:ref>CONTINUATION</x:ref>
            frames) can
            only appear at the start or end of a stream. An endpoint that receives a
            <x:ref>HEADERS</x:ref>
            frame without the END_STREAM flag set after receiving a final
            (non-informational) status code MUST treat the corresponding request or response as<xref
                target="malformed">malformed</xref>.
        </t>

        <t>
            An HTTP request/response exchange fully consumes a single stream. A request starts with
            the
            <x:ref>HEADERS</x:ref>
            frame that puts the stream into an "open" state. The request
            ends with a frame bearing END_STREAM, which causes the stream to become "half-closed
            (local)" for the client and "half-closed (remote)" for the server. A response starts with
            a
            <x:ref>HEADERS</x:ref>
            frame and ends with a frame bearing END_STREAM, which places the
            stream in the "closed" state.
        </t>

        <t>
            An HTTP response is complete after the server sends &mdash; or the client receives &mdash; a frame
            with the END_STREAM flag set (including any
            <x:ref>CONTINUATION</x:ref>
            frames needed to
            complete a header block). A server can send a complete response prior to the client
            sending an entire request if the response does not depend on any portion of the request
            that has not been sent and received. When this is true, a server MAY request that the
            client abort transmission of a request without error by sending a
            <x:ref>RST_STREAM</x:ref>
            with an error code of
            <x:ref>NO_ERROR</x:ref>
            after sending a
            complete response (i.e., a frame with the END_STREAM flag). Clients MUST NOT discard
            responses as a result of receiving such a<x:ref>RST_STREAM</x:ref>, though clients can
            always discard responses at their discretion for other reasons.
        </t>

        <section anchor="informational-responses" title="Upgrading from HTTP/2">
            <t>
                HTTP/2 removes support for the 101 (Switching Protocols) informational status code
                (<xref target="RFC7231" x:fmt="," x:rel="#status.101"/>).
            </t>
            <t>
                The semantics of 101 (Switching Protocols) aren't applicable to a multiplexed protocol.
                Alternative protocols are able to use the same mechanisms that HTTP/2 uses to negotiate
                their use (see<xref target="starting"/>).
            </t>
        </section>

        <section anchor="HttpHeaders" title="HTTP Header Fields">
            <t>
                HTTP header fields carry information as a series of key-value pairs. For a listing of
                registered HTTP headers, see the "Message Header Field" registry maintained at<eref
                    target="https://www.iana.org/assignments/message-headers"/>.
            </t>
            <t>
                Just as in HTTP/1.x, header field names are strings of ASCII characters that are
                compared in a case-insensitive fashion. However, header field names MUST be converted
                to lowercase prior to their encoding in HTTP/2. A request or response containing
                uppercase header field names MUST be treated as<xref
                    target="malformed">malformed</xref>.
            </t>

            <section anchor="PseudoHeaderFields" title="Pseudo-Header Fields">
                <t>
                    While HTTP/1.x used the message start-line (see<xref target="RFC7230" x:fmt=","
                                                                         x:rel="#start.line"/>) to convey the
                    target URI, the method of the request, and the
                    status code for the response, HTTP/2 uses special pseudo-header fields beginning with
                    ':' character (ASCII 0x3a) for this purpose.
                </t>
                <t>
                    Pseudo-header fields are not HTTP header fields. Endpoints MUST NOT generate
                    pseudo-header fields other than those defined in this document.
                </t>
                <t>
                    Pseudo-header fields are only valid in the context in which they are defined.
                    Pseudo-header fields defined for requests MUST NOT appear in responses; pseudo-header
                    fields defined for responses MUST NOT appear in requests. Pseudo-header fields MUST
                    NOT appear in trailers. Endpoints MUST treat a request or response that contains
                    undefined or invalid pseudo-header fields as<xref
                        target="malformed">malformed</xref>.
                </t>
                <t>
                    All pseudo-header fields MUST appear in the header block before regular header fields.
                    Any request or response that contains a pseudo-header field that appears in a header
                    block after a regular header field MUST be treated as<xref
                        target="malformed">malformed</xref>.
                </t>
            </section>

            <section title="Connection-Specific Header Fields">
                <t>
                    HTTP/2 does not use the
                    <spanx style="vbare">Connection</spanx>
                    header field to
                    indicate connection-specific header fields; in this protocol, connection-specific
                    metadata is conveyed by other means. An endpoint MUST NOT generate an HTTP/2 message
                    containing connection-specific header fields; any message containing
                    connection-specific header fields MUST be treated as<xref
                        target="malformed">malformed</xref>.
                </t>
                <t>
                    The only exception to this is the TE header field, which MAY be present in an HTTP/2
                    request; when it is, it MUST NOT contain any value other than "trailers".
                </t>
                <t>
                    This means that an intermediary transforming an HTTP/1.x message to HTTP/2 will need
                    to remove any header fields nominated by the Connection header field, along with the
                    Connection header field itself. Such intermediaries SHOULD also remove other
                    connection-specific header fields, such as Keep-Alive, Proxy-Connection,
                    Transfer-Encoding, and Upgrade, even if they are not nominated by the Connection header
                    field.
                </t>
                <x:note>
                    <t>
                        <x:h>Note:</x:h>
                        HTTP/2 purposefully does not support upgrade to another protocol. The handshake
                        methods described in
                        <xref target="starting"/>
                        are believed sufficient to
                        negotiate the use of alternative protocols.
                    </t>
                </x:note>
            </section>

            <section anchor="HttpRequest" title="Request Pseudo-Header Fields">
                <t>
                    The following pseudo-header fields are defined for HTTP/2 requests:
                    <list style="symbols">
                        <x:lt>
                            <t>
                                The
                                <spanx style="verb">:method</spanx>
                                pseudo-header field includes the HTTP
                                method (<xref target="RFC7231" x:fmt="," x:rel="#methods"/>).
                            </t>
                        </x:lt>
                        <x:lt>
                            <t>
                                The
                                <spanx style="verb">:scheme</spanx>
                                pseudo-header field includes the scheme
                                portion of the target URI (<xref target="RFC3986" x:fmt="," x:sec="3.1"/>).
                            </t>
                            <t>
                                <spanx style="verb">:scheme</spanx>
                                is not restricted to
                                <spanx
                                        style="verb">http
                                </spanx>
                                and
                                <spanx style="verb">https</spanx>
                                schemed URIs. A
                                proxy or gateway can translate requests for non-HTTP schemes, enabling the use
                                of HTTP to interact with non-HTTP services.
                            </t>
                        </x:lt>
                        <x:lt>
                            <t>
                                The
                                <spanx style="verb">:authority</spanx>
                                pseudo-header field includes the
                                authority portion of the target URI (<xref target="RFC3986" x:fmt=","
                                                                           x:sec="3.2"/>). The authority MUST
                                NOT include the deprecated
                                <spanx
                                        style="verb">userinfo
                                </spanx>
                                subcomponent for
                                <spanx style="verb">http</spanx>
                                or
                                <spanx style="verb">https</spanx>
                                schemed URIs.
                            </t>
                            <t>
                                To ensure that the HTTP/1.1 request line can be reproduced accurately, this
                                pseudo-header field MUST be omitted when translating from an HTTP/1.1 request
                                that has a request target in origin or asterisk form (see<xref target="RFC7230"
                                                                                               x:fmt=","
                                                                                               x:rel="#request-target"/>
                                ). Clients that generate HTTP/2 requests
                                directly SHOULD use the
                                <spanx style="verb">:authority</spanx>
                                pseudo-header
                                field instead of the
                                <spanx style="vbare">Host</spanx>
                                header field. An
                                intermediary that converts an HTTP/2 request to HTTP/1.1 MUST create a
                                <spanx
                                        style="vbare">Host
                                </spanx>
                                header field if one is not present in a request by
                                copying the value of the
                                <spanx style="verb">:authority</spanx>
                                pseudo-header
                                field.
                            </t>
                        </x:lt>
                        <x:lt>
                            <t>
                                The
                                <spanx style="verb">:path</spanx>
                                pseudo-header field includes the path and
                                query parts of the target URI (the
                                <spanx style="verb">path-absolute</spanx>
                                production and optionally a '?' character followed by the
                                <spanx style="verb">query</spanx>
                                production (see Sections
                                <xref target="RFC3986" x:fmt="number" x:sec="3.3"/>
                                and
                                <xref target="RFC3986" x:fmt="number"
                                      x:sec="3.4"/>
                                of<xref target="RFC3986"/>). A request in asterisk form includes the value '*'
                                for the
                                <spanx style="verb">:path</spanx>
                                pseudo-header field.
                            </t>
                            <t>
                                This pseudo-header field MUST NOT be empty for
                                <spanx style="verb">http</spanx>
                                or
                                <spanx style="verb">https</spanx>
                                URIs;
                                <spanx style="verb">http</spanx>
                                or
                                <spanx style="verb">https</spanx>
                                URIs that do not contain a path component
                                MUST include a value of '/'. The exception to this rule is an OPTIONS request
                                for an
                                <spanx style="verb">http</spanx>
                                or
                                <spanx style="verb">https</spanx>
                                URI that does not include a path component; these MUST include a
                                <spanx
                                        style="verb">:path
                                </spanx>
                                pseudo-header field with a value of '*' (see<xref
                                    target="RFC7230" x:fmt="," x:rel="#asterisk-form"/>).
                            </t>
                        </x:lt>
                    </list>
                </t>
                <t>
                    All HTTP/2 requests MUST include exactly one valid value for the<spanx
                        style="verb">:method</spanx>,<spanx style="verb">:scheme</spanx>, and
                    <spanx
                            style="verb">:path
                    </spanx>
                    pseudo-header fields, unless it is a<xref
                        target="CONNECT">CONNECT request</xref>. An HTTP request that omits mandatory
                    pseudo-header fields is<xref target="malformed">malformed</xref>.
                </t>
                <t>
                    HTTP/2 does not define a way to carry the version identifier that is included in the
                    HTTP/1.1 request line.
                </t>
            </section>

            <section anchor="HttpResponse" title="Response Pseudo-Header Fields">
                <t>
                    For HTTP/2 responses, a single
                    <spanx style="verb">:status</spanx>
                    pseudo-header
                    field is defined that carries the HTTP status code field (see<xref target="RFC7231"
                                                                                       x:fmt=","
                                                                                       x:rel="#status.codes"/>).
                    This pseudo-header field MUST be included in all
                    responses; otherwise, the response is<xref target="malformed">malformed</xref>.
                </t>
                <t>
                    HTTP/2 does not define a way to carry the version or reason phrase that is included in
                    an HTTP/1.1 status line.
                </t>
            </section>

            <section anchor="CompressCookie" title="Compressing the Cookie Header Field">
                <t>
                    The
                    <xref target="COOKIE">Cookie header field</xref>
                    uses a semi-colon (";") to delimit cookie-pairs (or "crumbs").
                    This header field doesn't follow the list construction rules in HTTP (see<xref
                        target="RFC7230" x:fmt="," x:rel="#field.order"/>), which prevents cookie-pairs from
                    being separated into different name-value pairs. This can significantly reduce
                    compression efficiency as individual cookie-pairs are updated.
                </t>
                <t>
                    To allow for better compression efficiency, the Cookie header field MAY be split into
                    separate header fields, each with one or more cookie-pairs. If there are multiple
                    Cookie header fields after decompression, these MUST be concatenated into a single
                    octet string using the two-octet delimiter of 0x3B, 0x20 (the ASCII string "; ")
                    before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a
                    generic HTTP server application.
                </t>
                <figure>
                    <preamble>
                        Therefore, the following two lists of Cookie header fields are semantically
                        equivalent.
                    </preamble>
                    <artwork type="inline"><![CDATA[
  cookie: a=b; c=d; e=f

  cookie: a=b
  cookie: c=d
  cookie: e=f
]]></artwork>
                </figure>
            </section>

            <section anchor="malformed" title="Malformed Requests and Responses">
                <t>
                    A malformed request or response is one that is an otherwise valid sequence of HTTP/2
                    frames but is invalid due to the presence of extraneous frames, prohibited
                    header fields, the absence of mandatory header fields, or the inclusion of uppercase
                    header field names.
                </t>
                <t>
                    A request or response that includes a payload body can include a
                    <spanx
                            style="vbare">content-length
                    </spanx>
                    header field. A request or response is also
                    malformed if the value of a
                    <spanx style="vbare">content-length</spanx>
                    header field
                    does not equal the sum of the
                    <x:ref>DATA</x:ref>
                    frame payload lengths that form the
                    body. A response that is defined to have no payload, as described in<xref
                        target="RFC7230" x:fmt="," x:rel="#header.content-length"/>, can have a non-zero
                    <spanx style="vbare">content-length</spanx>
                    header field, even though no content is
                    included in
                    <x:ref>DATA</x:ref>
                    frames.
                </t>
                <t>
                    Intermediaries that process HTTP requests or responses (i.e., any intermediary not
                    acting as a tunnel) MUST NOT forward a malformed request or response. Malformed
                    requests or responses that are detected MUST be treated as a
                    <xref
                            target="StreamErrorHandler">stream error
                    </xref>
                    of type<x:ref>PROTOCOL_ERROR</x:ref>.
                </t>
                <t>
                    For malformed requests, a server MAY send an HTTP response prior to closing or
                    resetting the stream. Clients MUST NOT accept a malformed response. Note that these
                    requirements are intended to protect against several types of common attacks against
                    HTTP; they are deliberately strict because being permissive can expose
                    implementations to these vulnerabilities.
                </t>
            </section>
        </section>

        <section title="Examples">
            <t>
                This section shows HTTP/1.1 requests and responses, with illustrations of equivalent
                HTTP/2 requests and responses.
            </t>
            <t>
                An HTTP GET request includes request header fields and no payload body and is therefore
                transmitted as a single
                <x:ref>HEADERS</x:ref>
                frame, followed by zero or more
                <x:ref>CONTINUATION</x:ref>
                frames containing the serialized block of request header
                fields. The
                <x:ref>HEADERS</x:ref>
                frame in the following has both the END_HEADERS and
                END_STREAM flags set; no
                <x:ref>CONTINUATION</x:ref>
                frames are sent.
            </t>

            <figure>
                <artwork type="inline"><![CDATA[
  GET /resource HTTP/1.1           HEADERS
  Host: example.org          ==>     + END_STREAM
  Accept: image/jpeg                 + END_HEADERS
                                       :method = GET
                                       :scheme = https
                                       :path = /resource
                                       host = example.org
                                       accept = image/jpeg
]]></artwork>
            </figure>

            <t>
                Similarly, a response that includes only response header fields is transmitted as a
                <x:ref>HEADERS</x:ref>
                frame (again, followed by zero or more
                <x:ref>CONTINUATION</x:ref>
                frames) containing the serialized block of response header
                fields.
            </t>

            <figure>
                <artwork type="inline"><![CDATA[
  HTTP/1.1 304 Not Modified        HEADERS
  ETag: "xyzzy"              ==>     + END_STREAM
  Expires: Thu, 23 Jan ...           + END_HEADERS
                                       :status = 304
                                       etag = "xyzzy"
                                       expires = Thu, 23 Jan ...
]]></artwork>
            </figure>

            <t>
                An HTTP POST request that includes request header fields and payload data is transmitted
                as one
                <x:ref>HEADERS</x:ref>
                frame, followed by zero or more
                <x:ref>CONTINUATION</x:ref>
                frames containing the request header fields, followed by one
                or more
                <x:ref>DATA</x:ref>
                frames, with the last
                <x:ref>CONTINUATION</x:ref>
                (or
                <x:ref>HEADERS</x:ref>) frame having the END_HEADERS flag set and the final
                <x:ref>DATA</x:ref>
                frame having the END_STREAM flag set:
            </t>

            <figure>
                <artwork type="inline"><![CDATA[
  POST /resource HTTP/1.1          HEADERS
  Host: example.org          ==>     - END_STREAM
  Content-Type: image/jpeg           - END_HEADERS
  Content-Length: 123                  :method = POST
                                       :path = /resource
  {binary data}                        :scheme = https

                                   CONTINUATION
                                     + END_HEADERS
                                       content-type = image/jpeg
                                       host = example.org
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
]]></artwork>
                <postamble>
                    Note that data contributing to any given header field could be spread between header
                    block fragments. The allocation of header fields to frames in this example is
                    illustrative only.
                </postamble>
            </figure>

            <t>
                A response that includes header fields and payload data is transmitted as a
                <x:ref>HEADERS</x:ref>
                frame, followed by zero or more
                <x:ref>CONTINUATION</x:ref>
                frames, followed by one or more
                <x:ref>DATA</x:ref>
                frames, with the last
                <x:ref>DATA</x:ref>
                frame in the sequence having the END_STREAM flag set:
            </t>

            <figure>
                <artwork type="inline"><![CDATA[
  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Content-Length: 123                + END_HEADERS
                                       :status = 200
  {binary data}                        content-type = image/jpeg
                                       content-length = 123

                                   DATA
                                     + END_STREAM
                                   {binary data}
]]></artwork>
            </figure>

            <t>
                An informational response using a 1xx status code other than 101 is transmitted as a
                <x:ref>HEADERS</x:ref>
                frame, followed by zero or more
                <x:ref>CONTINUATION</x:ref>
                frames.
            </t>
            <t>
                Trailing header fields are sent as a header block after both the request or response
                header block and all the
                <x:ref>DATA</x:ref>
                frames have been sent. The
                <x:ref>HEADERS</x:ref>
                frame starting the trailers header block has the END_STREAM flag
                set.
            </t>
            <figure>
                <preamble>
                    The following example includes both a 100 (Continue) status code, which is sent in
                    response to a request containing a "100-continue" token in the Expect header field,
                    and trailing header fields:
                </preamble>
                <artwork type="inline"><![CDATA[
  HTTP/1.1 100 Continue            HEADERS
  Extension-Field: bar       ==>     - END_STREAM
                                     + END_HEADERS
                                       :status = 100
                                       extension-field = bar

  HTTP/1.1 200 OK                  HEADERS
  Content-Type: image/jpeg   ==>     - END_STREAM
  Transfer-Encoding: chunked         + END_HEADERS
  Trailer: Foo                         :status = 200
                                       content-length = 123
  123                                  content-type = image/jpeg
  {binary data}                        trailer = Foo
  0
  Foo: bar                         DATA
                                     - END_STREAM
                                   {binary data}

                                   HEADERS
                                     + END_STREAM
                                     + END_HEADERS
                                       foo = bar
]]></artwork>
            </figure>
        </section>

        <section anchor="Reliability" title="Request Reliability Mechanisms in HTTP/2">
            <t>
                In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error
                occurs because there is no means to determine the nature of the error. It is possible
                that some server processing occurred prior to the error, which could result in
                undesirable effects if the request were reattempted.
            </t>
            <t>
                HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has
                not been processed:
                <list style="symbols">
                    <t>
                        The
                        <x:ref>GOAWAY</x:ref>
                        frame indicates the highest stream number that might have
                        been processed. Requests on streams with higher numbers are therefore guaranteed to
                        be safe to retry.
                    </t>
                    <t>
                        The
                        <x:ref>REFUSED_STREAM</x:ref>
                        error code can be included in a
                        <x:ref>RST_STREAM</x:ref>
                        frame to indicate that the stream is being closed prior to
                        any processing having occurred. Any request that was sent on the reset stream can
                        be safely retried.
                    </t>
                </list>
            </t>
            <t>
                Requests that have not been processed have not failed; clients MAY automatically retry
                them, even those with non-idempotent methods.
            </t>
            <t>
                A server MUST NOT indicate that a stream has not been processed unless it can guarantee
                that fact. If frames that are on a stream are passed to the application layer for any
                stream, then
                <x:ref>REFUSED_STREAM</x:ref>
                MUST NOT be used for that stream, and a
                <x:ref>GOAWAY</x:ref>
                frame MUST include a stream identifier that is greater than or
                equal to the given stream identifier.
            </t>
            <t>
                In addition to these mechanisms, the
                <x:ref>PING</x:ref>
                frame provides a way for a
                client to easily test a connection. Connections that remain idle can become broken as
                some middleboxes (for instance, network address translators or load balancers) silently
                discard connection bindings. The
                <x:ref>PING</x:ref>
                frame allows a client to safely
                test whether a connection is still active without sending a request.
            </t>
        </section>
    </section>

    <section anchor="PushResources" title="Server Push">
        <t>
            HTTP/2 allows a server to pre-emptively send (or "push") responses (along with
            corresponding "promised" requests) to a client in association with a previous
            client-initiated request. This can be useful when the server knows the client will need
            to have those responses available in order to fully process the response to the original
            request.
        </t>

        <t>
            A client can request that server push be disabled, though this is negotiated for each hop
            independently. The
            <x:ref>SETTINGS_ENABLE_PUSH</x:ref>
            setting can be set to 0 to indicate
            that server push is disabled.
        </t>
        <t>
            Promised requests MUST be cacheable (see<xref target="RFC7231" x:fmt=","
                                                          x:rel="#cacheable.methods"/>), MUST be safe (see<xref
                target="RFC7231" x:fmt=","
                x:rel="#safe.methods"/>), and MUST NOT include a request body. Clients that receive a
            promised request that is not cacheable, that is not known to be safe, or that indicates the
            presence of a request body MUST reset the promised stream with a
            <xref
                    target="StreamErrorHandler">stream error
            </xref>
            of type<x:ref>PROTOCOL_ERROR</x:ref>.
            Note this could result in the promised stream being reset if the client does not recognize
            a newly defined method as being safe.
        </t>
        <t>
            Pushed responses that are cacheable (see<xref target="RFC7234" x:fmt=","
                                                          x:rel="#response.cacheability"/>) can be stored by the
            client, if it implements an HTTP
            cache. Pushed responses are considered successfully validated on the origin server (e.g.,
            if the "no-cache" cache response directive is present (<xref target="RFC7234" x:fmt=","
                                                                         x:rel="#cache-response-directive"/>))
            while the stream identified by the
            promised stream ID is still open.
        </t>
        <t>
            Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY
            be made available to the application separately.
        </t>
        <t>
            The server MUST include a value in the
            <spanx style="verb">:authority</spanx>
            pseudo-header field
            for which the server is authoritative (see<xref target="authority"/>). A client MUST
            treat a
            <x:ref>PUSH_PROMISE</x:ref>
            for which the server is not authoritative as a
            <xref
                    target="StreamErrorHandler">stream error
            </xref>
            of type<x:ref>PROTOCOL_ERROR</x:ref>.
        </t>
        <t>
            An intermediary can receive pushes from the server and choose not to forward them on to
            the client. In other words, how to make use of the pushed information is up to that
            intermediary. Equally, the intermediary might choose to make additional pushes to the
            client, without any action taken by the server.
        </t>
        <t>
            A client cannot push. Thus, servers MUST treat the receipt of a
            <x:ref>PUSH_PROMISE</x:ref>
            frame as a
            <xref target="ConnectionErrorHandler">connection
                error
            </xref>
            of type<x:ref>PROTOCOL_ERROR</x:ref>. Clients MUST reject any attempt to
            change the
            <x:ref>SETTINGS_ENABLE_PUSH</x:ref>
            setting to a value other than 0 by treating
            the message as a
            <xref target="ConnectionErrorHandler">connection error</xref>
            of type
            <x:ref>PROTOCOL_ERROR</x:ref>.
        </t>

        <section anchor="PushRequests" title="Push Requests">
            <t>
                Server push is semantically equivalent to a server responding to a request; however, in
                this case, that request is also sent by the server, as a
                <x:ref>PUSH_PROMISE</x:ref>
                frame.
            </t>
            <t>
                The
                <x:ref>PUSH_PROMISE</x:ref>
                frame includes a header block that contains a complete
                set of request header fields that the server attributes to the request. It is not
                possible to push a response to a request that includes a request body.
            </t>

            <t>
                Pushed responses are always associated with an explicit request from the client. The
                <x:ref>PUSH_PROMISE</x:ref>
                frames sent by the server are sent on that explicit
                request's stream. The
                <x:ref>PUSH_PROMISE</x:ref>
                frame also includes a promised stream
                identifier, chosen from the stream identifiers available to the server (see<xref
                    target="StreamIdentifiers"/>).
            </t>

            <t>
                The header fields in
                <x:ref>PUSH_PROMISE</x:ref>
                and any subsequent
                <x:ref>CONTINUATION</x:ref>
                frames MUST be a valid and complete set of<xref
                    target="HttpRequest">request header fields</xref>. The server MUST include a method in
                the
                <spanx style="verb">:method</spanx>
                pseudo-header field that is safe and cacheable. If a
                client receives a
                <x:ref>PUSH_PROMISE</x:ref>
                that does not include a complete and valid
                set of header fields or the
                <spanx style="verb">:method</spanx>
                pseudo-header field identifies
                a method that is not safe, it MUST respond with a
                <xref
                        target="StreamErrorHandler">stream error
                </xref>
                of type<x:ref>PROTOCOL_ERROR</x:ref>.
            </t>

            <t>
                The server SHOULD send
                <x:ref>PUSH_PROMISE</x:ref>
                (<xref target="PUSH_PROMISE"/>)
                frames prior to sending any frames that reference the promised responses. This avoids a
                race where clients issue requests prior to receiving any
                <x:ref>PUSH_PROMISE</x:ref>
                frames.
            </t>
            <t>
                For example, if the server receives a request for a document containing embedded links
                to multiple image files and the server chooses to push those additional images to the
                client, sending
                <x:ref>PUSH_PROMISE</x:ref>
                frames before the
                <x:ref>DATA</x:ref>
                frames that contain the
                image links ensures that the client is able to see that a resource will be pushed
                before discovering embedded links. Similarly, if the server pushes responses referenced by the
                header block
                (for instance, in Link header fields), sending a
                <x:ref>PUSH_PROMISE</x:ref>
                before sending the
                header block ensures that clients do not request those resources.
            </t>

            <t>
                <x:ref>PUSH_PROMISE</x:ref>
                frames MUST NOT be sent by the client.
            </t>
            <t>
                <x:ref>PUSH_PROMISE</x:ref>
                frames can be sent by the server in response to any
                client-initiated stream, but the stream MUST be in either the "open" or "half-closed
                (remote)" state with respect to the server.
                <x:ref>PUSH_PROMISE</x:ref>
                frames are
                interspersed with the frames that comprise a response, though they cannot be
                interspersed with
                <x:ref>HEADERS</x:ref>
                and
                <x:ref>CONTINUATION</x:ref>
                frames that
                comprise a single header block.
            </t>
            <t>
                Sending a
                <x:ref>PUSH_PROMISE</x:ref>
                frame creates a new stream and puts the stream
                into the “reserved (local)” state for the server and the “reserved (remote)” state for
                the client.
            </t>
        </section>

        <section anchor="PushResponses" title="Push Responses">
            <t>
                After sending the
                <x:ref>PUSH_PROMISE</x:ref>
                frame, the server can begin delivering the
                pushed response as a
                <xref target="HttpResponse">response</xref>
                on a server-initiated
                stream that uses the promised stream identifier. The server uses this stream to
                transmit an HTTP response, using the same sequence of frames as defined in<xref
                    target="HttpSequence"/>. This stream becomes
                <xref target="StreamStates">"half-closed"
                    to the client
                </xref>
                after the initial
                <x:ref>HEADERS</x:ref>
                frame is sent.
            </t>

            <t>
                Once a client receives a
                <x:ref>PUSH_PROMISE</x:ref>
                frame and chooses to accept the
                pushed response, the client SHOULD NOT issue any requests for the promised response
                until after the promised stream has closed.
            </t>

            <t>
                If the client determines, for any reason, that it does not wish to receive the pushed
                response from the server or if the server takes too long to begin sending the promised
                response, the client can send a
                <x:ref>RST_STREAM</x:ref>
                frame, using either the
                <x:ref>CANCEL</x:ref>
                or
                <x:ref>REFUSED_STREAM</x:ref>
                code and referencing the pushed
                stream's identifier.
            </t>
            <t>
                A client can use the
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>
                setting to limit the
                number of responses that can be concurrently pushed by a server. Advertising a
                <x:ref>SETTINGS_MAX_CONCURRENT_STREAMS</x:ref>
                value of zero disables server push by
                preventing the server from creating the necessary streams. This does not prohibit a
                server from sending
                <x:ref>PUSH_PROMISE</x:ref>
                frames; clients need to reset any
                promised streams that are not wanted.
            </t>

            <t>
                Clients receiving a pushed response MUST validate that either the server is
                authoritative (see<xref target="authority"/>) or the proxy that provided the pushed
                response is configured for the corresponding request. For example, a server that offers
                a certificate for only the
                <spanx style="verb">example.com</spanx>
                DNS-ID or Common Name
                is not permitted to push a response for<spanx
                    style="verb">https://www.example.org/doc</spanx>.
            </t>
            <t>
                The response for a
                <x:ref>PUSH_PROMISE</x:ref>
                stream begins with a
                <x:ref>HEADERS</x:ref>
                frame, which immediately puts the stream into the "half-closed
                (remote)" state for the server and "half-closed (local)" state for the client, and ends
                with a frame bearing END_STREAM, which places the stream in the "closed" state.
            </t>
            <x:note>
                <t>
                    <x:h>Note:</x:h>
                    The client never sends a frame with the END_STREAM flag for a server push.
                </t>
            </x:note>
        </section>

    </section>

    <section anchor="CONNECT" title="The CONNECT Method">
        <t>
            In HTTP/1.x, the pseudo-method CONNECT (<xref target="RFC7231" x:fmt=","
                                                          x:rel="#CONNECT"/>) is used to convert an HTTP
            connection into a tunnel to a remote host.
            CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin
            server for the purposes of interacting with
            <spanx style="verb">https</spanx>
            resources.
        </t>
        <t>
            In HTTP/2, the CONNECT method is used to establish a tunnel over a single HTTP/2 stream to
            a remote host for similar purposes. The HTTP header field mapping works as defined in
            <xref target="HttpRequest"/>
            ("<xref target="HttpRequest" format="title"/>"), with a few
            differences. Specifically:
            <list style="symbols">
                <t>
                    The
                    <spanx style="verb">:method</spanx>
                    pseudo-header field is set to<spanx
                        style="verb">CONNECT</spanx>.
                </t>
                <t>
                    The
                    <spanx style="verb">:scheme</spanx>
                    and
                    <spanx style="verb">:path</spanx>
                    pseudo-header
                    fields MUST be omitted.
                </t>
                <t>
                    The
                    <spanx style="verb">:authority</spanx>
                    pseudo-header field contains the host and port to
                    connect to (equivalent to the authority-form of the request-target of CONNECT
                    requests (see<xref target="RFC7230" x:fmt="," x:rel="#request-target"/>)).
                </t>
            </list>
        </t>
        <t>
            A CONNECT request that does not conform to these restrictions is<xref
                target="malformed">malformed</xref>.
        </t>
        <t>
            A proxy that supports CONNECT establishes a
            <xref target="TCP">TCP connection</xref>
            to
            the server identified in the
            <spanx style="verb">:authority</spanx>
            pseudo-header field. Once
            this connection is successfully established, the proxy sends a
            <x:ref>HEADERS</x:ref>
            frame containing a 2xx series status code to the client, as defined in<xref
                target="RFC7231" x:fmt="," x:rel="#CONNECT"/>.
        </t>
        <t>
            After the initial
            <x:ref>HEADERS</x:ref>
            frame sent by each peer, all subsequent
            <x:ref>DATA</x:ref>
            frames correspond to data sent on the TCP connection. The payload of
            any
            <x:ref>DATA</x:ref>
            frames sent by the client is transmitted by the proxy to the TCP
            server; data received from the TCP server is assembled into
            <x:ref>DATA</x:ref>
            frames by
            the proxy. Frame types other than
            <x:ref>DATA</x:ref>
            or stream management frames
            (<x:ref>RST_STREAM</x:ref>,<x:ref>WINDOW_UPDATE</x:ref>, and<x:ref>PRIORITY</x:ref>)
            MUST NOT be sent on a connected stream and MUST be treated as a
            <xref
                    target="StreamErrorHandler">stream error
            </xref>
            if received.
        </t>
        <t>
            The TCP connection can be closed by either peer. The END_STREAM flag on a
            <x:ref>DATA</x:ref>
            frame is treated as being equivalent to the TCP FIN bit. A client is
            expected to send a
            <x:ref>DATA</x:ref>
            frame with the END_STREAM flag set after receiving
            a frame bearing the END_STREAM flag. A proxy that receives a
            <x:ref>DATA</x:ref>
            frame
            with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP
            segment. A proxy that receives a TCP segment with the FIN bit set sends a
            <x:ref>DATA</x:ref>
            frame with the END_STREAM flag set. Note that the final TCP segment
            or
            <x:ref>DATA</x:ref>
            frame could be empty.
        </t>
        <t>
            A TCP connection error is signaled with<x:ref>RST_STREAM</x:ref>. A proxy treats any
            error in the TCP connection, which includes receiving a TCP segment with the RST bit set,
            as a
            <xref target="StreamErrorHandler">stream error</xref>
            of type
            <x:ref>CONNECT_ERROR</x:ref>. Correspondingly, a proxy MUST send a TCP segment with the
            RST bit set if it detects an error with the stream or the HTTP/2 connection.
        </t>
    </section>
</section>